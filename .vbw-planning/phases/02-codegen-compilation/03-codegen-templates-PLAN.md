# Plan 03: Go Code Generation Templates

## Goal

Generate a complete, self-contained Go project (main.go + go.mod) that compiles into a working CLI binary with one subcommand per MCP tool.

## Wave

2 (depends on Plan 01 for schema types, Plan 02 for auth patterns)

## Requirements

REQ-36, REQ-37, REQ-38, REQ-39, REQ-40, REQ-41, REQ-42, REQ-43, REQ-44, REQ-45, REQ-46, REQ-47

## Tasks

### T1: Define generation context type

In `internal/codegen/codegen.go`:

```go
type GenerateContext struct {
    CLIName         string           // Generated CLI binary name
    ServerURL       string           // MCP server URL (for HTTP)
    StdioCommand    string           // Stdio command (for stdio)
    StdioArgs       []string         // Stdio command args
    EnvKeys         []string         // Env var keys to embed (not values)
    Tools           []ToolDef        // Tool definitions with options
    ClihubVersion   string           // clihub version for header comment
    IsHTTP          bool             // HTTP or stdio transport
}

type ToolDef struct {
    Name        string              // Original MCP tool name (e.g., "list_issues")
    CommandName string              // Kebab-case command (e.g., "list-issues")
    Description string
    Options     []schema.ToolOption // From Plan 01
}
```

### T2: Implement main.go template

Go text/template that generates a complete main.go:

**Structure of generated code:**
1. Header comment: `// Code generated by clihub vX.Y.Z. DO NOT EDIT.`
2. Package main, imports
3. Embedded server config (URL or command+args+env keys)
4. Root cobra command with CLI name, global flags:
   - `-t, --timeout <ms>` (default 30000)
   - `-o, --output <format>` (text|json|markdown|raw, default text)
   - `--auth-token <token>` (override env/credentials)
5. Per-tool subcommands:
   - Command name: kebab-case, alias: original underscore name
   - Per-option flags from schema (StringVar, IntVar, Float64Var, BoolVar, StringSliceVar)
   - `--raw <json>` flag per tool
   - RunE handler:
     a. If --raw: parse JSON directly
     b. Else: build args map from flags
     c. Connect to MCP (HTTP or stdio)
     d. Initialize handshake
     e. Call tools/call with args
     f. Format and print result
     g. Close connection
6. Output formatters: text, json, markdown, raw
7. Auth credential lookup: flag → CLIHUB_AUTH_TOKEN env → credentials.json
8. MCP client code: minimal JSON-RPC client embedded directly (no external deps)
9. Main function

### T3: Implement go.mod template

Generate go.mod with:
- Module name from CLI name
- `go 1.22`
- `require github.com/spf13/cobra vX.Y.Z` (only dependency)

### T4: Implement Generate function

`Generate(ctx GenerateContext, outputDir string) error`:
1. Create temp directory
2. Execute main.go template → write to temp dir
3. Execute go.mod template → write to temp dir
4. Run `go mod tidy` in temp dir to resolve dependencies
5. Return temp dir path (compilation happens in Plan 04)

### T5: Enum validation in generated code

For options with EnumValues, generate runtime validation:
```go
if !isValidEnum(value, []string{"open", "closed"}) {
    return fmt.Errorf("invalid value %q for --%s: must be one of: %s", value, flagName, strings.Join(enum, ", "))
}
```

### T6: Unit tests

- Template rendering produces valid Go code
- `go vet` passes on generated code
- Tools with various option types render correctly
- Enum validation generates correctly
- Auth lookup code is present
- Header comment includes version

## Acceptance Criteria

1. Generated main.go compiles with `go build`
2. Generated CLI has subcommands for each tool
3. Each subcommand has flags matching the tool's schema
4. --raw flag bypasses individual flags
5. Output formatters work (text, json, markdown, raw)
6. Auth token lookup follows priority chain
7. Header comment includes clihub version
8. go.mod has correct module and dependencies
9. Generated code passes `go vet`

## Estimated Complexity

High — largest plan in the project, complex template with embedded MCP client
