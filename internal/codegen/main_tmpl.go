package codegen

const mainTemplateSource = `// Code generated by clihub v{{.ClihubVersion}}. DO NOT EDIT.
package main

import (
	"bufio"
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/spf13/cobra"
)

// --- Embedded server configuration ---
{{- if .IsHTTP}}
const serverURL = {{quote .ServerURL}}
{{- else}}
var stdioCommand = {{quote .StdioCommand}}
var stdioArgs = {{quoteSlice .StdioArgs}}
var envKeys = {{quoteSlice .EnvKeys}}
{{- end}}

// --- Global flags ---
var (
	globalTimeout   int
	globalOutput    string
	globalAuthToken string
)

func main() {
	rootCmd := &cobra.Command{
		Use:   {{quote .CLIName}},
		Short: {{quote (printf "CLI for %s MCP server" .CLIName)}},
		SilenceUsage:  true,
		SilenceErrors: true,
	}

	rootCmd.PersistentFlags().IntVarP(&globalTimeout, "timeout", "t", 30000, "per-call timeout in milliseconds")
	rootCmd.PersistentFlags().StringVarP(&globalOutput, "output", "o", "text", "output format: text|json|markdown|raw")
	rootCmd.PersistentFlags().StringVar(&globalAuthToken, "auth-token", "", "bearer token for authenticated MCP servers")

{{- range .Tools}}
	rootCmd.AddCommand(cmd{{funcName .Name}}())
{{- end}}

	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %s\n", err)
		os.Exit(1)
	}
}

// --- Tool commands ---
{{range .Tools}}
func cmd{{funcName .Name}}() *cobra.Command {
{{- range .Options}}
	var {{varName .FlagName}} {{.GoType}}
{{- end}}
	var flagRaw string

	cmd := &cobra.Command{
		Use:     {{quote .CommandName}},
		Aliases: []string{ {{quote .Name}} },
		Short:   {{quote .Description}},
		SilenceUsage:  true,
		SilenceErrors: true,
		RunE: func(cmd *cobra.Command, args []string) error {
			params := make(map[string]interface{})
			if flagRaw != "" {
				if err := json.Unmarshal([]byte(flagRaw), &params); err != nil {
					return fmt.Errorf("invalid --raw JSON: %w", err)
				}
			} else {
{{- range .Options}}
{{- if eq .GoType "string"}}
				if {{varName .FlagName}} != "" {
					params[{{quote .PropertyName}}] = {{varName .FlagName}}
				}
{{- else if eq .GoType "int"}}
				if cmd.Flags().Changed({{quote .FlagName}}) {
					params[{{quote .PropertyName}}] = {{varName .FlagName}}
				}
{{- else if eq .GoType "float64"}}
				if cmd.Flags().Changed({{quote .FlagName}}) {
					params[{{quote .PropertyName}}] = {{varName .FlagName}}
				}
{{- else if eq .GoType "bool"}}
				if cmd.Flags().Changed({{quote .FlagName}}) {
					params[{{quote .PropertyName}}] = {{varName .FlagName}}
				}
{{- else if eq .GoType "[]string"}}
				if len({{varName .FlagName}}) > 0 {
					params[{{quote .PropertyName}}] = {{varName .FlagName}}
				}
{{- else if eq .GoType "[]int"}}
				if len({{varName .FlagName}}) > 0 {
					params[{{quote .PropertyName}}] = {{varName .FlagName}}
				}
{{- end}}
{{- end}}
			}
{{range .Options}}{{if .EnumValues}}
			// Validate enum for {{.FlagName}}
			if v, ok := params[{{quote .PropertyName}}]; ok {
				if s, ok := v.(string); ok {
					valid := {{quoteSlice .EnumValues}}
					found := false
					for _, e := range valid {
						if s == e {
							found = true
							break
						}
					}
					if !found {
						return fmt.Errorf("invalid value %q for --%s: must be one of: %s", s, {{quote .FlagName}}, strings.Join(valid, ", "))
					}
				}
			}
{{end}}{{end}}
			return callTool({{quote .Name}}, params)
		},
	}

{{- range .Options}}
	cmd.Flags().{{cobraFlag .GoType}}(&{{varName .FlagName}}, {{quote .FlagName}}, {{defaultLit .GoType .DefaultValue}}, {{quote (hasEnumDesc .Description .EnumValues)}})
{{- end}}
	cmd.Flags().StringVar(&flagRaw, "raw", "", "raw JSON arguments (bypasses all other flags)")

	return cmd
}
{{end}}

// --- MCP client ---

type jsonRPCRequest struct {
	JSONRPC string      ` + "`" + `json:"jsonrpc"` + "`" + `
	ID      int         ` + "`" + `json:"id"` + "`" + `
	Method  string      ` + "`" + `json:"method"` + "`" + `
	Params  interface{} ` + "`" + `json:"params,omitempty"` + "`" + `
}

type jsonRPCResponse struct {
	JSONRPC string          ` + "`" + `json:"jsonrpc"` + "`" + `
	ID      int             ` + "`" + `json:"id"` + "`" + `
	Result  json.RawMessage ` + "`" + `json:"result,omitempty"` + "`" + `
	Error   *jsonRPCError   ` + "`" + `json:"error,omitempty"` + "`" + `
}

type jsonRPCError struct {
	Code    int    ` + "`" + `json:"code"` + "`" + `
	Message string ` + "`" + `json:"message"` + "`" + `
}

type mcpTransport interface {
	send(ctx context.Context, req *jsonRPCRequest) (*jsonRPCResponse, error)
	close() error
}

// --- HTTP transport ---

type httpTransport struct {
	url       string
	authToken string
	client    *http.Client
	sessionID string
}

func (t *httpTransport) send(ctx context.Context, req *jsonRPCRequest) (*jsonRPCResponse, error) {
	body, err := json.Marshal(req)
	if err != nil {
		return nil, err
	}

	httpReq, err := http.NewRequestWithContext(ctx, http.MethodPost, t.url, bytes.NewReader(body))
	if err != nil {
		return nil, err
	}

	httpReq.Header.Set("Content-Type", "application/json")
	httpReq.Header.Set("Accept", "application/json, text/event-stream")

	if t.authToken != "" {
		httpReq.Header.Set("Authorization", "Bearer "+t.authToken)
	}
	if t.sessionID != "" {
		httpReq.Header.Set("Mcp-Session-Id", t.sessionID)
	}

	resp, err := t.client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if sid := resp.Header.Get("Mcp-Session-Id"); sid != "" {
		t.sessionID = sid
	}

	if resp.StatusCode != http.StatusOK {
		respBody, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("http status %d: %s", resp.StatusCode, string(respBody))
	}

	ct := resp.Header.Get("Content-Type")
	if strings.HasPrefix(ct, "text/event-stream") {
		return parseSSE(resp.Body, req.ID)
	}

	var rpcResp jsonRPCResponse
	if err := json.NewDecoder(resp.Body).Decode(&rpcResp); err != nil {
		return nil, err
	}
	return &rpcResp, nil
}

func (t *httpTransport) close() error { return nil }

func parseSSE(r io.Reader, reqID int) (*jsonRPCResponse, error) {
	scanner := bufio.NewScanner(r)
	for scanner.Scan() {
		line := scanner.Text()
		if !strings.HasPrefix(line, "data: ") {
			continue
		}
		data := strings.TrimPrefix(line, "data: ")
		var resp jsonRPCResponse
		if err := json.Unmarshal([]byte(data), &resp); err != nil {
			continue
		}
		if resp.ID == reqID {
			return &resp, nil
		}
	}
	return nil, fmt.Errorf("no response in SSE stream")
}

// --- Stdio transport ---

type stdioTransport struct {
	cmd    *exec.Cmd
	stdin  io.WriteCloser
	reader *bufio.Reader
	mu     sync.Mutex
}

func newStdioTransport(command string, args, envOverrides []string) (*stdioTransport, error) {
	cmd := exec.Command(command, args...)

	// Merge environment
	env := os.Environ()
	for _, key := range envOverrides {
		val := os.Getenv(key)
		if val == "" {
			return nil, fmt.Errorf("required environment variable %s is not set", key)
		}
		env = append(env, key+"="+val)
	}
	cmd.Env = env
	cmd.Stderr = os.Stderr

	stdin, err := cmd.StdinPipe()
	if err != nil {
		return nil, err
	}
	stdout, err := cmd.StdoutPipe()
	if err != nil {
		return nil, err
	}
	if err := cmd.Start(); err != nil {
		return nil, err
	}

	return &stdioTransport{
		cmd:    cmd,
		stdin:  stdin,
		reader: bufio.NewReader(stdout),
	}, nil
}

func (t *stdioTransport) send(_ context.Context, req *jsonRPCRequest) (*jsonRPCResponse, error) {
	t.mu.Lock()
	defer t.mu.Unlock()

	data, err := json.Marshal(req)
	if err != nil {
		return nil, err
	}
	data = append(data, '\n')

	if _, err := t.stdin.Write(data); err != nil {
		return nil, err
	}

	line, err := t.reader.ReadBytes('\n')
	if err != nil {
		return nil, err
	}

	var resp jsonRPCResponse
	if err := json.Unmarshal(line, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (t *stdioTransport) close() error {
	if t.stdin != nil {
		t.stdin.Close()
	}
	if t.cmd.Process != nil {
		t.cmd.Process.Kill()
	}
	_ = t.cmd.Wait()
	return nil
}

// --- Tool call orchestration ---

func callTool(toolName string, params map[string]interface{}) error {
	token := lookupToken()

	timeout := time.Duration(globalTimeout) * time.Millisecond
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()

	transport, err := createTransport(token)
	if err != nil {
		return err
	}
	defer transport.close()

	// Initialize handshake
	nextID := 1
	initReq := &jsonRPCRequest{
		JSONRPC: "2.0",
		ID:      nextID,
		Method:  "initialize",
		Params: map[string]interface{}{
			"protocolVersion": "2024-11-05",
			"capabilities":    map[string]interface{}{},
			"clientInfo":      map[string]interface{}{"name": {{quote .CLIName}}, "version": "1.0.0"},
		},
	}
	nextID++

	initResp, err := transport.send(ctx, initReq)
	if err != nil {
		if ctx.Err() != nil {
			return fmt.Errorf("tool call timed out after %dms", globalTimeout)
		}
		return fmt.Errorf("MCP handshake failed: %w", err)
	}
	if initResp.Error != nil {
		return fmt.Errorf("MCP handshake error: %s", initResp.Error.Message)
	}

	// Send initialized notification
	notifReq := &jsonRPCRequest{JSONRPC: "2.0", ID: nextID, Method: "notifications/initialized"}
	nextID++
	_, _ = transport.send(ctx, notifReq)

	// Call tool
	callReq := &jsonRPCRequest{
		JSONRPC: "2.0",
		ID:      nextID,
		Method:  "tools/call",
		Params: map[string]interface{}{
			"name":      toolName,
			"arguments": params,
		},
	}

	callResp, err := transport.send(ctx, callReq)
	if err != nil {
		if ctx.Err() != nil {
			return fmt.Errorf("tool call timed out after %dms", globalTimeout)
		}
		return fmt.Errorf("tool call failed: %w", err)
	}
	if callResp.Error != nil {
		return fmt.Errorf("tool error: %s", callResp.Error.Message)
	}

	return formatOutput(callResp.Result, globalOutput)
}

func createTransport(token string) (mcpTransport, error) {
{{- if .IsHTTP}}
	return &httpTransport{
		url:       serverURL,
		authToken: token,
		client:    &http.Client{},
	}, nil
{{- else}}
	return newStdioTransport(stdioCommand, stdioArgs, envKeys)
{{- end}}
}

// --- Output formatting ---

func formatOutput(result json.RawMessage, format string) error {
	switch format {
	case "json":
		var pretty bytes.Buffer
		if err := json.Indent(&pretty, result, "", "  "); err != nil {
			fmt.Println(string(result))
			return nil
		}
		fmt.Println(pretty.String())

	case "raw":
		fmt.Println(string(result))

	case "markdown":
		text := extractText(result)
		fmt.Println(text)

	default: // "text"
		text := extractText(result)
		fmt.Println(text)
	}
	return nil
}

func extractText(result json.RawMessage) string {
	// Try to parse as MCP tool result with content array
	var toolResult struct {
		Content []struct {
			Type string ` + "`" + `json:"type"` + "`" + `
			Text string ` + "`" + `json:"text"` + "`" + `
		} ` + "`" + `json:"content"` + "`" + `
	}
	if err := json.Unmarshal(result, &toolResult); err == nil && len(toolResult.Content) > 0 {
		var parts []string
		for _, c := range toolResult.Content {
			if c.Text != "" {
				parts = append(parts, c.Text)
			}
		}
		if len(parts) > 0 {
			return strings.Join(parts, "\n")
		}
	}

	// Try as plain string
	var s string
	if err := json.Unmarshal(result, &s); err == nil {
		return s
	}

	// Fallback: pretty-printed JSON
	var pretty bytes.Buffer
	if err := json.Indent(&pretty, result, "", "  "); err == nil {
		return pretty.String()
	}
	return string(result)
}

// --- Auth ---

func lookupToken() string {
	// 1. Flag
	if globalAuthToken != "" {
		return globalAuthToken
	}

	// 2. Environment variable
	if token := os.Getenv("CLIHUB_AUTH_TOKEN"); token != "" {
		return token
	}

	// 3. Credentials file
	credPath := os.Getenv("CLIHUB_CREDENTIALS_FILE")
	if credPath == "" {
		home, err := os.UserHomeDir()
		if err == nil {
			credPath = filepath.Join(home, ".clihub", "credentials.json")
		}
	}
	if credPath != "" {
		data, err := os.ReadFile(credPath)
		if err == nil {
			var creds struct {
				Servers map[string]struct {
					Token string ` + "`" + `json:"token"` + "`" + `
				} ` + "`" + `json:"servers"` + "`" + `
			}
			if json.Unmarshal(data, &creds) == nil {
{{- if .IsHTTP}}
				if s, ok := creds.Servers[serverURL]; ok {
					return s.Token
				}
{{- end}}
			}
		}
	}

	return ""
}
`

const goModTemplateSource = `module {{.CLIName}}

go 1.22

require github.com/spf13/cobra v1.10.2

require (
	github.com/inconshreveable/mousetrap v1.1.0 // indirect
	github.com/spf13/pflag v1.0.9 // indirect
)
`
